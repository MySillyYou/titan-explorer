// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/gnasnik/titan-explorer/core/generated/model"
)

func newDeviceInfo(db *gorm.DB, opts ...gen.DOOption) deviceInfo {
	_deviceInfo := deviceInfo{}

	_deviceInfo.deviceInfoDo.UseDB(db, opts...)
	_deviceInfo.deviceInfoDo.UseModel(&model.DeviceInfo{})

	tableName := _deviceInfo.deviceInfoDo.TableName()
	_deviceInfo.ALL = field.NewAsterisk(tableName)
	_deviceInfo.ID = field.NewInt64(tableName, "id")
	_deviceInfo.CreatedAt = field.NewTime(tableName, "created_at")
	_deviceInfo.UpdatedAt = field.NewTime(tableName, "updated_at")
	_deviceInfo.DeletedAt = field.NewField(tableName, "deleted_at")
	_deviceInfo.DeviceID = field.NewString(tableName, "device_id")
	_deviceInfo.Secret = field.NewString(tableName, "secret")
	_deviceInfo.NodeType = field.NewInt32(tableName, "node_type")
	_deviceInfo.DeviceName = field.NewString(tableName, "device_name")
	_deviceInfo.UserID = field.NewString(tableName, "user_id")
	_deviceInfo.SnCode = field.NewString(tableName, "sn_code")
	_deviceInfo.Operator = field.NewString(tableName, "operator")
	_deviceInfo.NetworkType = field.NewString(tableName, "network_type")
	_deviceInfo.TodayIncome = field.NewFloat64(tableName, "today_income")
	_deviceInfo.YesterdayIncome = field.NewFloat64(tableName, "yesterday_income")
	_deviceInfo.CumuProfit = field.NewFloat64(tableName, "cumu_profit")
	_deviceInfo.SystemVersion = field.NewString(tableName, "system_version")
	_deviceInfo.ProductType = field.NewString(tableName, "product_type")
	_deviceInfo.NetworkInfo = field.NewString(tableName, "network_info")
	_deviceInfo.ExternalIP = field.NewString(tableName, "external_ip")
	_deviceInfo.InternalIP = field.NewString(tableName, "internal_ip")
	_deviceInfo.IPLocation = field.NewString(tableName, "ip_location")
	_deviceInfo.MacLocation = field.NewString(tableName, "mac_location")
	_deviceInfo.NatType = field.NewString(tableName, "nat_type")
	_deviceInfo.Upnp = field.NewString(tableName, "upnp")
	_deviceInfo.PkgLossRatio = field.NewFloat64(tableName, "pkg_loss_ratio")
	_deviceInfo.NatRatio = field.NewFloat64(tableName, "nat_ratio")
	_deviceInfo.Latency = field.NewFloat64(tableName, "latency")
	_deviceInfo.CPUUsage = field.NewFloat64(tableName, "cpu_usage")
	_deviceInfo.MemoryUsage = field.NewFloat64(tableName, "memory_usage")
	_deviceInfo.DiskUsage = field.NewFloat64(tableName, "disk_usage")
	_deviceInfo.WorkStatus = field.NewString(tableName, "work_status")
	_deviceInfo.DeviceStatus = field.NewString(tableName, "device_status")
	_deviceInfo.DiskType = field.NewString(tableName, "disk_type")
	_deviceInfo.IoSystem = field.NewString(tableName, "io_system")
	_deviceInfo.TodayOnlineTime = field.NewFloat64(tableName, "today_online_time")
	_deviceInfo.TodayProfit = field.NewFloat64(tableName, "today_profit")
	_deviceInfo.SevenDaysProfit = field.NewFloat64(tableName, "seven_days_profit")
	_deviceInfo.MonthProfit = field.NewFloat64(tableName, "month_profit")
	_deviceInfo.BandwidthUp = field.NewFloat64(tableName, "bandwidth_up")
	_deviceInfo.BandwidthDown = field.NewFloat64(tableName, "bandwidth_down")

	_deviceInfo.fillFieldMap()

	return _deviceInfo
}

type deviceInfo struct {
	deviceInfoDo

	ALL             field.Asterisk
	ID              field.Int64
	CreatedAt       field.Time
	UpdatedAt       field.Time
	DeletedAt       field.Field
	DeviceID        field.String
	Secret          field.String
	NodeType        field.Int32
	DeviceName      field.String
	UserID          field.String
	SnCode          field.String
	Operator        field.String
	NetworkType     field.String
	TodayIncome     field.Float64
	YesterdayIncome field.Float64
	CumuProfit      field.Float64
	SystemVersion   field.String
	ProductType     field.String
	NetworkInfo     field.String
	ExternalIP      field.String
	InternalIP      field.String
	IPLocation      field.String
	MacLocation     field.String
	NatType         field.String
	Upnp            field.String
	PkgLossRatio    field.Float64
	NatRatio        field.Float64 // Nat
	Latency         field.Float64
	CPUUsage        field.Float64
	MemoryUsage     field.Float64
	DiskUsage       field.Float64
	WorkStatus      field.String
	DeviceStatus    field.String
	DiskType        field.String
	IoSystem        field.String
	TodayOnlineTime field.Float64
	TodayProfit     field.Float64
	SevenDaysProfit field.Float64
	MonthProfit     field.Float64
	BandwidthUp     field.Float64
	BandwidthDown   field.Float64

	fieldMap map[string]field.Expr
}

func (d deviceInfo) Table(newTableName string) *deviceInfo {
	d.deviceInfoDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d deviceInfo) As(alias string) *deviceInfo {
	d.deviceInfoDo.DO = *(d.deviceInfoDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *deviceInfo) updateTableName(table string) *deviceInfo {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")
	d.DeletedAt = field.NewField(table, "deleted_at")
	d.DeviceID = field.NewString(table, "device_id")
	d.Secret = field.NewString(table, "secret")
	d.NodeType = field.NewInt32(table, "node_type")
	d.DeviceName = field.NewString(table, "device_name")
	d.UserID = field.NewString(table, "user_id")
	d.SnCode = field.NewString(table, "sn_code")
	d.Operator = field.NewString(table, "operator")
	d.NetworkType = field.NewString(table, "network_type")
	d.TodayIncome = field.NewFloat64(table, "today_income")
	d.YesterdayIncome = field.NewFloat64(table, "yesterday_income")
	d.CumuProfit = field.NewFloat64(table, "cumu_profit")
	d.SystemVersion = field.NewString(table, "system_version")
	d.ProductType = field.NewString(table, "product_type")
	d.NetworkInfo = field.NewString(table, "network_info")
	d.ExternalIP = field.NewString(table, "external_ip")
	d.InternalIP = field.NewString(table, "internal_ip")
	d.IPLocation = field.NewString(table, "ip_location")
	d.MacLocation = field.NewString(table, "mac_location")
	d.NatType = field.NewString(table, "nat_type")
	d.Upnp = field.NewString(table, "upnp")
	d.PkgLossRatio = field.NewFloat64(table, "pkg_loss_ratio")
	d.NatRatio = field.NewFloat64(table, "nat_ratio")
	d.Latency = field.NewFloat64(table, "latency")
	d.CPUUsage = field.NewFloat64(table, "cpu_usage")
	d.MemoryUsage = field.NewFloat64(table, "memory_usage")
	d.DiskUsage = field.NewFloat64(table, "disk_usage")
	d.WorkStatus = field.NewString(table, "work_status")
	d.DeviceStatus = field.NewString(table, "device_status")
	d.DiskType = field.NewString(table, "disk_type")
	d.IoSystem = field.NewString(table, "io_system")
	d.TodayOnlineTime = field.NewFloat64(table, "today_online_time")
	d.TodayProfit = field.NewFloat64(table, "today_profit")
	d.SevenDaysProfit = field.NewFloat64(table, "seven_days_profit")
	d.MonthProfit = field.NewFloat64(table, "month_profit")
	d.BandwidthUp = field.NewFloat64(table, "bandwidth_up")
	d.BandwidthDown = field.NewFloat64(table, "bandwidth_down")

	d.fillFieldMap()

	return d
}

func (d *deviceInfo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *deviceInfo) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 40)
	d.fieldMap["id"] = d.ID
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
	d.fieldMap["deleted_at"] = d.DeletedAt
	d.fieldMap["device_id"] = d.DeviceID
	d.fieldMap["secret"] = d.Secret
	d.fieldMap["node_type"] = d.NodeType
	d.fieldMap["device_name"] = d.DeviceName
	d.fieldMap["user_id"] = d.UserID
	d.fieldMap["sn_code"] = d.SnCode
	d.fieldMap["operator"] = d.Operator
	d.fieldMap["network_type"] = d.NetworkType
	d.fieldMap["today_income"] = d.TodayIncome
	d.fieldMap["yesterday_income"] = d.YesterdayIncome
	d.fieldMap["cumu_profit"] = d.CumuProfit
	d.fieldMap["system_version"] = d.SystemVersion
	d.fieldMap["product_type"] = d.ProductType
	d.fieldMap["network_info"] = d.NetworkInfo
	d.fieldMap["external_ip"] = d.ExternalIP
	d.fieldMap["internal_ip"] = d.InternalIP
	d.fieldMap["ip_location"] = d.IPLocation
	d.fieldMap["mac_location"] = d.MacLocation
	d.fieldMap["nat_type"] = d.NatType
	d.fieldMap["upnp"] = d.Upnp
	d.fieldMap["pkg_loss_ratio"] = d.PkgLossRatio
	d.fieldMap["nat_ratio"] = d.NatRatio
	d.fieldMap["latency"] = d.Latency
	d.fieldMap["cpu_usage"] = d.CPUUsage
	d.fieldMap["memory_usage"] = d.MemoryUsage
	d.fieldMap["disk_usage"] = d.DiskUsage
	d.fieldMap["work_status"] = d.WorkStatus
	d.fieldMap["device_status"] = d.DeviceStatus
	d.fieldMap["disk_type"] = d.DiskType
	d.fieldMap["io_system"] = d.IoSystem
	d.fieldMap["today_online_time"] = d.TodayOnlineTime
	d.fieldMap["today_profit"] = d.TodayProfit
	d.fieldMap["seven_days_profit"] = d.SevenDaysProfit
	d.fieldMap["month_profit"] = d.MonthProfit
	d.fieldMap["bandwidth_up"] = d.BandwidthUp
	d.fieldMap["bandwidth_down"] = d.BandwidthDown
}

func (d deviceInfo) clone(db *gorm.DB) deviceInfo {
	d.deviceInfoDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d deviceInfo) replaceDB(db *gorm.DB) deviceInfo {
	d.deviceInfoDo.ReplaceDB(db)
	return d
}

type deviceInfoDo struct{ gen.DO }

type IDeviceInfoDo interface {
	gen.SubQuery
	Debug() IDeviceInfoDo
	WithContext(ctx context.Context) IDeviceInfoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDeviceInfoDo
	WriteDB() IDeviceInfoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDeviceInfoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDeviceInfoDo
	Not(conds ...gen.Condition) IDeviceInfoDo
	Or(conds ...gen.Condition) IDeviceInfoDo
	Select(conds ...field.Expr) IDeviceInfoDo
	Where(conds ...gen.Condition) IDeviceInfoDo
	Order(conds ...field.Expr) IDeviceInfoDo
	Distinct(cols ...field.Expr) IDeviceInfoDo
	Omit(cols ...field.Expr) IDeviceInfoDo
	Join(table schema.Tabler, on ...field.Expr) IDeviceInfoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDeviceInfoDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDeviceInfoDo
	Group(cols ...field.Expr) IDeviceInfoDo
	Having(conds ...gen.Condition) IDeviceInfoDo
	Limit(limit int) IDeviceInfoDo
	Offset(offset int) IDeviceInfoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDeviceInfoDo
	Unscoped() IDeviceInfoDo
	Create(values ...*model.DeviceInfo) error
	CreateInBatches(values []*model.DeviceInfo, batchSize int) error
	Save(values ...*model.DeviceInfo) error
	First() (*model.DeviceInfo, error)
	Take() (*model.DeviceInfo, error)
	Last() (*model.DeviceInfo, error)
	Find() ([]*model.DeviceInfo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DeviceInfo, err error)
	FindInBatches(result *[]*model.DeviceInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DeviceInfo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDeviceInfoDo
	Assign(attrs ...field.AssignExpr) IDeviceInfoDo
	Joins(fields ...field.RelationField) IDeviceInfoDo
	Preload(fields ...field.RelationField) IDeviceInfoDo
	FirstOrInit() (*model.DeviceInfo, error)
	FirstOrCreate() (*model.DeviceInfo, error)
	FindByPage(offset int, limit int) (result []*model.DeviceInfo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDeviceInfoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d deviceInfoDo) Debug() IDeviceInfoDo {
	return d.withDO(d.DO.Debug())
}

func (d deviceInfoDo) WithContext(ctx context.Context) IDeviceInfoDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d deviceInfoDo) ReadDB() IDeviceInfoDo {
	return d.Clauses(dbresolver.Read)
}

func (d deviceInfoDo) WriteDB() IDeviceInfoDo {
	return d.Clauses(dbresolver.Write)
}

func (d deviceInfoDo) Session(config *gorm.Session) IDeviceInfoDo {
	return d.withDO(d.DO.Session(config))
}

func (d deviceInfoDo) Clauses(conds ...clause.Expression) IDeviceInfoDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d deviceInfoDo) Returning(value interface{}, columns ...string) IDeviceInfoDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d deviceInfoDo) Not(conds ...gen.Condition) IDeviceInfoDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d deviceInfoDo) Or(conds ...gen.Condition) IDeviceInfoDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d deviceInfoDo) Select(conds ...field.Expr) IDeviceInfoDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d deviceInfoDo) Where(conds ...gen.Condition) IDeviceInfoDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d deviceInfoDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IDeviceInfoDo {
	return d.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (d deviceInfoDo) Order(conds ...field.Expr) IDeviceInfoDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d deviceInfoDo) Distinct(cols ...field.Expr) IDeviceInfoDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d deviceInfoDo) Omit(cols ...field.Expr) IDeviceInfoDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d deviceInfoDo) Join(table schema.Tabler, on ...field.Expr) IDeviceInfoDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d deviceInfoDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDeviceInfoDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d deviceInfoDo) RightJoin(table schema.Tabler, on ...field.Expr) IDeviceInfoDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d deviceInfoDo) Group(cols ...field.Expr) IDeviceInfoDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d deviceInfoDo) Having(conds ...gen.Condition) IDeviceInfoDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d deviceInfoDo) Limit(limit int) IDeviceInfoDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d deviceInfoDo) Offset(offset int) IDeviceInfoDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d deviceInfoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDeviceInfoDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d deviceInfoDo) Unscoped() IDeviceInfoDo {
	return d.withDO(d.DO.Unscoped())
}

func (d deviceInfoDo) Create(values ...*model.DeviceInfo) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d deviceInfoDo) CreateInBatches(values []*model.DeviceInfo, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d deviceInfoDo) Save(values ...*model.DeviceInfo) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d deviceInfoDo) First() (*model.DeviceInfo, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DeviceInfo), nil
	}
}

func (d deviceInfoDo) Take() (*model.DeviceInfo, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DeviceInfo), nil
	}
}

func (d deviceInfoDo) Last() (*model.DeviceInfo, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DeviceInfo), nil
	}
}

func (d deviceInfoDo) Find() ([]*model.DeviceInfo, error) {
	result, err := d.DO.Find()
	return result.([]*model.DeviceInfo), err
}

func (d deviceInfoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DeviceInfo, err error) {
	buf := make([]*model.DeviceInfo, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d deviceInfoDo) FindInBatches(result *[]*model.DeviceInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d deviceInfoDo) Attrs(attrs ...field.AssignExpr) IDeviceInfoDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d deviceInfoDo) Assign(attrs ...field.AssignExpr) IDeviceInfoDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d deviceInfoDo) Joins(fields ...field.RelationField) IDeviceInfoDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d deviceInfoDo) Preload(fields ...field.RelationField) IDeviceInfoDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d deviceInfoDo) FirstOrInit() (*model.DeviceInfo, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DeviceInfo), nil
	}
}

func (d deviceInfoDo) FirstOrCreate() (*model.DeviceInfo, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DeviceInfo), nil
	}
}

func (d deviceInfoDo) FindByPage(offset int, limit int) (result []*model.DeviceInfo, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d deviceInfoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d deviceInfoDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d deviceInfoDo) Delete(models ...*model.DeviceInfo) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *deviceInfoDo) withDO(do gen.Dao) *deviceInfoDo {
	d.DO = *do.(*gen.DO)
	return d
}
